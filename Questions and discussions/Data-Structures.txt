Design a Hash Table

It's a fairly standard interview question that shows you understand the underlying concepts being useful Java data structures, like HashSets and HashMaps.
You would use an array of lists, these are normally referred to as buckets. You start your hashtable with a given capacity n meaning you have a array of
10 lists (all empty). To add an object to your hastable you call the objects hashCode function which gives you an int (a number in a pretty big range).
So you then have to modulo the hashCode wrt to n to give you the bucket it lives in. Add the object to the end of the list in that bucket. To find an object
you again use the hashCode and mod function to find the bucket and then need to iterate through the list using .equals() to find the correct object.
As the table gets fuller, you will end up doing more and more linear searching, so you will eventually need to re-hash. This means building an entirely new,
larger table and putting the objects into it again. Instead of using a List in each array position you can recalulate a different bucket position
if the one you want is full, a common method is quadratic probing. This has the advantage of not needed any dynamic data structures like lists but is
more complicated.

How does hash table deal with collisions?

Hash tables deal with collisions in one of two ways.
Option 1: By having each bucket contain a linked list of elements that are hashed to that bucket. This is why a bad hash function can make lookups in hash tables
very slow.
Option 2: If the hash table entries are all full then the hash table can increase the number of buckets that it has and then redistribute all the elements in
the table. The hash function returns an integer and the hash table has to take the result of the hash function and mod it against the size of the table that
way it can be sure it will get to bucket. so by increasing the size it will rehash and run the modulo calculations which if you are lucky might send the
objects to different buckets.
Java uses both option 1 and 2 in its hash table implementations.
